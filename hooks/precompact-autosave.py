#!/usr/bin/env python3
"""precompact-autosave.py
PreCompact hook — saves state before context compression.

Two outputs:
1. Human-readable snapshot → log/{TIMESTAMP}-compact.md  (existing behaviour)
2. Machine-readable state  → ~/.claude/sessions/{hash}/pre-compact-state.json
   (new — read back by postcompact-restore.py after compaction)
"""

import hashlib
import json
import os
import re
import sys
from datetime import datetime
from pathlib import Path

TASK_MGMT = Path.home() / "Library" / "CloudStorage" / "YOUR-CLOUD" / "Task Management"
LOG_DIR = TASK_MGMT / "log"
PLANS_DIR = LOG_DIR / "plans"
FOCUS_FILE = TASK_MGMT / ".context" / "current-focus.md"
SESSIONS_BASE = Path.home() / ".claude" / "sessions"


def project_hash() -> str:
    """Deterministic hash of the project directory (same approach as Pedro's)."""
    project_dir = os.environ.get("CLAUDE_PROJECT_DIR", os.getcwd())
    return hashlib.sha256(project_dir.encode()).hexdigest()[:12]


def latest_file(directory: Path, pattern: str = "*.md") -> Path | None:
    """Return the most recently modified file matching pattern, or None."""
    if not directory.is_dir():
        return None
    files = sorted(directory.glob(pattern), key=lambda f: f.stat().st_mtime, reverse=True)
    return files[0] if files else None


def active_plan() -> dict | None:
    """Find the latest plan file and extract its status + first unchecked item."""
    plan_file = latest_file(PLANS_DIR)
    if not plan_file:
        return None

    text = plan_file.read_text(encoding="utf-8", errors="replace")

    # Determine status from content markers
    status = "DRAFT"
    text_lower = text.lower()
    if "approved" in text_lower:
        status = "APPROVED"
    if "completed" in text_lower or "done" in text_lower:
        return None  # Skip completed plans

    # Find first unchecked item
    first_unchecked = None
    for line in text.splitlines():
        if re.match(r"\s*-\s*\[\s*\]", line):
            first_unchecked = line.strip()
            break

    return {
        "file": plan_file.name,
        "status": status,
        "first_unchecked": first_unchecked,
    }


def current_focus_headline() -> str | None:
    """Read the first 5 lines of current-focus.md."""
    if not FOCUS_FILE.is_file():
        return None
    lines = FOCUS_FILE.read_text(encoding="utf-8", errors="replace").splitlines()[:5]
    return "\n".join(lines) if lines else None


def recent_decisions(log_file: Path | None) -> list[str]:
    """Scan last 50 lines of the latest session log for decision patterns."""
    if not log_file or not log_file.is_file():
        return []

    lines = log_file.read_text(encoding="utf-8", errors="replace").splitlines()[-50:]
    pattern = re.compile(r"(Decision:|Decided:|Chose:|decision:|decided:|chose:)", re.IGNORECASE)
    decisions = []
    for line in lines:
        if pattern.search(line):
            decisions.append(line.strip())
    return decisions[:10]  # Cap at 10


def save_human_snapshot(hook_input: dict, timestamp: str) -> str:
    """Save the human-readable markdown snapshot (existing behaviour)."""
    LOG_DIR.mkdir(parents=True, exist_ok=True)

    session_id = hook_input.get("session_id", "unknown")
    cwd = hook_input.get("cwd", "unknown")
    trigger = hook_input.get("trigger", "unknown")
    transcript = hook_input.get("transcript_path", "unknown")

    now_display = datetime.now().strftime("%Y-%m-%d %H:%M")
    save_file = LOG_DIR / f"{timestamp}-compact.md"

    content = f"""# Auto-save before context compaction

- **Timestamp:** {now_display}
- **Session:** {session_id}
- **Working directory:** {cwd}
- **Trigger:** {trigger}

> This file was auto-generated by the PreCompact hook.
> Read the session transcript for full context.
> Transcript: {transcript}
"""
    save_file.write_text(content, encoding="utf-8")
    return save_file.name


def save_machine_state(hook_input: dict, timestamp: str) -> Path:
    """Save machine-readable JSON state for post-compact restoration."""
    phash = project_hash()
    state_dir = SESSIONS_BASE / phash
    state_dir.mkdir(parents=True, exist_ok=True)
    state_file = state_dir / "pre-compact-state.json"

    log_file = latest_file(LOG_DIR, "*.md")
    # Skip compact snapshots when finding the latest session log
    log_files = sorted(LOG_DIR.glob("*.md"), key=lambda f: f.stat().st_mtime, reverse=True)
    session_log = None
    for f in log_files:
        if "-compact" not in f.name:
            session_log = f
            break

    plan = active_plan()
    focus = current_focus_headline()
    decisions = recent_decisions(session_log)

    state = {
        "timestamp": timestamp,
        "session_id": hook_input.get("session_id", "unknown"),
        "cwd": hook_input.get("cwd", "unknown"),
        "active_plan": plan,
        "latest_session_log": session_log.name if session_log else None,
        "current_focus_headline": focus,
        "recent_decisions": decisions,
    }

    state_file.write_text(json.dumps(state, indent=2, ensure_ascii=False), encoding="utf-8")
    return state_file


def main():
    hook_input = json.loads(sys.stdin.read())
    timestamp = datetime.now().strftime("%Y-%m-%d-%H%M")

    # 1. Human-readable snapshot (existing)
    snapshot_name = save_human_snapshot(hook_input, timestamp)

    # 2. Machine-readable state (new)
    state_file = save_machine_state(hook_input, timestamp)

    # Output hook response
    output = {
        "systemMessage": (
            f"Auto-saved pre-compaction snapshot to log/{snapshot_name} "
            f"and state to {state_file}"
        )
    }
    print(json.dumps(output))

    # Exit code 2 = message visible in transcript
    sys.exit(2)


if __name__ == "__main__":
    main()
